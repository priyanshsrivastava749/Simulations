<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solenoid Magnetic Field Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
        }

        h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: #4facfe; text-align: center; }
        
        .control-group { margin-bottom: 20px; }
        .label-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9rem; }
        .value-display { font-weight: bold; color: #00f260; }
        
        input[type=range] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px #4facfe;
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }

        .legend {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #aaa;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 10px;
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; }
        
        .instructions {
            font-size: 0.8rem; 
            text-align: center; 
            margin-top: 10px; 
            color: #666;
            margin-bottom: 10px;
        }

        .footer-credits {
            text-align: center;
            font-size: 0.9rem;
            color: #4facfe;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        #loading {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        #loading h1 {
            color: #4facfe;
            font-size: 3rem;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
            animation: pulse 2s infinite;
        }

        #loading p {
            color: #888;
            font-size: 1.2rem;
        }

        @keyframes pulse {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.8; transform: scale(1); }
        }
    </style>
</head>
<body>

    <div id="loading">
        <h1>Created by Priyansh</h1>
        <p>Initializing Simulation...</p>
    </div>
    
    <div id="canvas-container"></div>

    <div id="ui-panel">
        <h2>Solenoid Simulator</h2>
        
        <div class="control-group">
            <div class="label-row">
                <span>Current (I)</span>
                <span id="current-val" class="value-display">2.0 A</span>
            </div>
            <input type="range" id="current-slider" min="0" max="10" step="0.1" value="2.0">
        </div>

        <div class="control-group">
            <div class="label-row">
                <span>Number of Turns (N)</span>
                <span id="turns-val" class="value-display">10</span>
            </div>
            <input type="range" id="turns-slider" min="4" max="40" step="1" value="10">
        </div>

        <div class="legend">
            <div class="legend-item"><div class="dot" style="background:#ffa500"></div>Copper Coil</div>
            <div class="legend-item"><div class="dot" style="background:#00f260; box-shadow: 0 0 5px #00f260"></div>Moving Electrons</div>
            <div class="legend-item"><div class="dot" style="background:#00aaff"></div>Magnetic Field (B)</div>
        </div>
        
        <div class="instructions">
            Left Click: Rotate | Right Click: Pan | Scroll: Zoom
        </div>

        <div class="footer-credits">
            Simulation by Priyansh
        </div>
    </div>

    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const SOLENOID_RADIUS = 3;
        const SOLENOID_LENGTH = 10;
        const TUBE_THICKNESS = 0.15;
        // FIELD_LINE_COUNT_RADIAL removed, now dynamic
        const FIELD_INTEGRATION_STEPS = 200;
        const FIELD_STEP_SIZE = 0.4;
        
        // State
        let state = {
            current: 2.0,
            turns: 10
        };

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x050505);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffaa00, 2, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);
        const pointLight2 = new THREE.PointLight(0x00aaff, 1, 100);
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);

        // --- Objects Container ---
        const solenoidGroup = new THREE.Group();
        scene.add(solenoidGroup);
        
        const electronGroup = new THREE.Group();
        scene.add(electronGroup);

        const fieldLinesGroup = new THREE.Group();
        scene.add(fieldLinesGroup);

        // Materials
        const copperMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffa500,
            metalness: 0.6,
            roughness: 0.3,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            emissive: 0xb87333,
            emissiveIntensity: 0.1
        });

        const electronMaterial = new THREE.MeshBasicMaterial({
            color: 0x00f260,
        });

        const fieldLineMaterial = new THREE.LineBasicMaterial({
            color: 0x00aaff,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        // --- Core Functions ---

        // 1. Generate Solenoid Geometry (Helix)
        let helixCurve = null; // Store curve for electron animation

        function createSolenoid(turns) {
            // Remove old mesh
            while(solenoidGroup.children.length > 0){ 
                solenoidGroup.remove(solenoidGroup.children[0]); 
            }
            
            // Parametric Helix Equation
            // x = r * cos(t), y = r * sin(t), z = (L * t) / (2 * pi * N) - L/2
            
            const points = [];
            const segments = turns * 32; // Resolution
            
            for (let i = 0; i <= segments; i++) {
                const t = (i / segments) * (turns * Math.PI * 2);
                const x = SOLENOID_RADIUS * Math.cos(t);
                const y = SOLENOID_RADIUS * Math.sin(t);
                const z = (SOLENOID_LENGTH * (i / segments)) - (SOLENOID_LENGTH / 2);
                points.push(new THREE.Vector3(x, y, z));
            }

            helixCurve = new THREE.CatmullRomCurve3(points);
            
            const tubeGeometry = new THREE.TubeGeometry(helixCurve, segments, TUBE_THICKNESS, 12, false);
            const tubeMesh = new THREE.Mesh(tubeGeometry, copperMaterial);
            solenoidGroup.add(tubeMesh);
        }

        // 2. Generate Electrons (Current simulation)
        const electrons = [];
        const ELECTRON_COUNT = 50;
        
        function initElectrons() {
            // Clear old
            while(electronGroup.children.length > 0) electronGroup.remove(electronGroup.children[0]);
            electrons.length = 0;

            const geometry = new THREE.SphereGeometry(0.15, 8, 8);
            
            for(let i=0; i<ELECTRON_COUNT; i++) {
                const mesh = new THREE.Mesh(geometry, electronMaterial);
                const progress = i / ELECTRON_COUNT; // Distribute evenly
                
                electronGroup.add(mesh);
                electrons.push({
                    mesh: mesh,
                    baseProgress: progress, // Starting position 0-1
                    speedOffset: 0
                });
            }
        }

        function updateElectrons(deltaTime) {
            if (!helixCurve) return;
            
            // Speed factor depends on Current (I)
            // If I = 0, speed = 0
            const speed = state.current * 0.1; 

            electrons.forEach(e => {
                e.speedOffset += speed * deltaTime;
                let currentPos = (e.baseProgress + e.speedOffset) % 1.0;
                
                // Get point on curve
                const point = helixCurve.getPointAt(currentPos);
                e.mesh.position.copy(point);
                e.mesh.visible = state.current > 0.1;
            });
        }

        // 3. Generate Magnetic Field Lines using Biot-Savart Numerical Integration
        // We approximate the solenoid as a series of discrete current loop segments
        
        function calculateBField(position, turns) {
            // Simplified Biot-Savart for visualization
            // B(r) = integral ( dl x r_hat ) / r^2
            // We'll just sample points along the helix curve
            
            const B = new THREE.Vector3(0,0,0);
            const samples = turns * 10; // Samples along the wire
            const curve = helixCurve;
            if(!curve) return B;

            const dL = new THREE.Vector3();
            const rVec = new THREE.Vector3();
            const crossProd = new THREE.Vector3();
            
            // To save performance, we only sample a subset of points on the wire
            // Realtime B-field calculation is expensive in JS
            const steps = Math.min(samples, 250); // Cap iterations for perf

            for(let i=0; i<steps; i++) {
                const t = i / (steps - 1);
                const p1 = curve.getPointAt(t);
                
                // Tangent vector (dL) approximated
                const tNext = Math.min(1, t + 0.01);
                const p2 = curve.getPointAt(tNext);
                dL.subVectors(p2, p1).normalize();

                // Vector from wire element to point
                rVec.subVectors(position, p1);
                const distSq = rVec.lengthSq();
                
                if(distSq < 0.1) continue; // Singularity check

                // Biot Savart: dL x rVec / dist^3 (since rVec is not normalized)
                crossProd.crossVectors(dL, rVec);
                crossProd.divideScalar(Math.pow(distSq, 1.5));
                
                B.add(crossProd);
            }
            
            return B.normalize(); // We only need direction for tracing
        }

        function generateFieldLines() {
            // NOTE: We don't show the loading screen here on subsequent updates
            // because it interrupts the flow. The main loading screen is only for init.
            // But we can show a small indicator if needed. For now, let's keep it smooth.
            
            while(fieldLinesGroup.children.length > 0) fieldLinesGroup.remove(fieldLinesGroup.children[0]);
            
            // --- DYNAMIC SEED POINTS ---
            // Here we calculate how many lines to draw based on 'turns'
            // Turns: 4 to 40
            // Scaling: ~0.5x turns + base.
            const densityFactor = state.turns * 0.6;
            const linesPerLayer = Math.floor(4 + densityFactor); 
            
            const seedPoints = [];
            
            // 1. Center axis (Always 1)
            seedPoints.push(new THREE.Vector3(0,0,0));

            // 2. Inner Layer (Close to axis)
            const innerRadius = SOLENOID_RADIUS * 0.3;
            for(let i=0; i<linesPerLayer; i++) {
                const angle = (i / linesPerLayer) * Math.PI * 2;
                seedPoints.push(new THREE.Vector3(
                    Math.cos(angle) * innerRadius,
                    Math.sin(angle) * innerRadius,
                    0
                ));
            }
            
            // 3. Middle Layer
            const midRadius = SOLENOID_RADIUS * 0.6;
            // Draw slightly fewer lines in outer layers or same? Let's do same for density feel.
            for(let i=0; i<linesPerLayer; i++) {
                // Offset angle slightly for 3D look
                const angle = ((i + 0.5) / linesPerLayer) * Math.PI * 2;
                seedPoints.push(new THREE.Vector3(
                    Math.cos(angle) * midRadius,
                    Math.sin(angle) * midRadius,
                    0
                ));
            }

            // 4. Outer Layer (Near coils)
            const outerRadius = SOLENOID_RADIUS * 0.85;
            for(let i=0; i<linesPerLayer; i++) {
                const angle = (i / linesPerLayer) * Math.PI * 2;
                seedPoints.push(new THREE.Vector3(
                    Math.cos(angle) * outerRadius,
                    Math.sin(angle) * outerRadius,
                    0
                ));
            }

            seedPoints.forEach(startPoint => {
                const points = [];
                const maxSteps = FIELD_INTEGRATION_STEPS;
                const stepSize = FIELD_STEP_SIZE;

                // Trace Forward
                let currPos = startPoint.clone();
                points.push(currPos.clone());
                
                for(let i=0; i<maxSteps; i++) {
                    const B = calculateBField(currPos, state.turns);
                    currPos.addScaledVector(B, stepSize);
                    points.push(currPos.clone());
                    if(currPos.length() > 25) break; // Out of bounds
                }
                
                // Trace Backward
                currPos = startPoint.clone();
                
                const backwardPoints = [];
                for(let i=0; i<maxSteps; i++) {
                    const B = calculateBField(currPos, state.turns);
                    currPos.addScaledVector(B, -stepSize); // Negative step
                    backwardPoints.push(currPos.clone());
                    if(currPos.length() > 25) break;
                }

                // Combine: Backward(reversed) + Start + Forward
                const fullLinePoints = [...backwardPoints.reverse(), ...points];

                const geometry = new THREE.BufferGeometry().setFromPoints(fullLinePoints);
                const line = new THREE.Line(geometry, fieldLineMaterial.clone());
                fieldLinesGroup.add(line);
            });

            updateFieldBrightness();
        }

        function updateFieldBrightness() {
            // Visual feedback: Higher current = Brighter lines
            const intensity = (state.current / 10) * 0.8 + 0.1; // Min opacity 0.1
            fieldLinesGroup.children.forEach(line => {
                line.material.opacity = intensity;
                // Color shift: Blue -> Cyan for high intensity
                if(state.current > 7) line.material.color.setHex(0x55ffff); 
                else line.material.color.setHex(0x00aaff);
            });
        }

        // --- Initialization ---
        function initSystem() {
            createSolenoid(state.turns);
            initElectrons();
            
            // Simulate loading delay for effect
            setTimeout(() => {
                generateFieldLines();
                
                // Hide loading screen after generation
                const loader = document.getElementById('loading');
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }, 1500); // 1.5 seconds to show "Created by Priyansh"
        }

        initSystem();

        // --- UI Handling ---
        const currentSlider = document.getElementById('current-slider');
        const turnsSlider = document.getElementById('turns-slider');
        const currentVal = document.getElementById('current-val');
        const turnsVal = document.getElementById('turns-val');

        currentSlider.addEventListener('input', (e) => {
            state.current = parseFloat(e.target.value);
            currentVal.innerText = state.current + " A";
            updateFieldBrightness();
        });

        turnsSlider.addEventListener('change', (e) => {
            // Re-generate geometry on change (release), not input (drag) to save perf
            state.turns = parseInt(e.target.value);
            turnsVal.innerText = state.turns;
            createSolenoid(state.turns);
            initElectrons(); // curve changed, reset electrons
            generateFieldLines(); // geometry changed, field changed
        });
        
        turnsSlider.addEventListener('input', (e) => {
             turnsVal.innerText = e.target.value;
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            controls.update();
            updateElectrons(delta);
            renderer.render(scene, camera);
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>