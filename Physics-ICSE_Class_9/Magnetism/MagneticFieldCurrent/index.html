<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electromagnet & Compass Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            color: white;
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 23, 42, 0.8);
            padding: 24px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            width: 300px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        h2 {
            margin: 0 0 20px 0;
            font-size: 1.5rem;
            font-weight: 600;
            background: linear-gradient(90deg, #818cf8, #c084fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .control-group {
            margin-bottom: 24px;
        }

        label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: #cbd5e1;
            font-size: 0.95rem;
            font-weight: 500;
        }

        /* Custom Range Slider */
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #818cf8;
            border: 2px solid #1e293b;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 0 10px rgba(129, 140, 248, 0.5);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #a5b4fc;
        }

        /* Toggle Switch */
        .switch-wrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #1e293b;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 52px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #475569;
            transition: .3s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input:checked+.slider {
            background-color: #10b981;
        }

        input:checked+.slider:before {
            transform: translateX(24px);
        }

        .instruction {
            margin-top: 20px;
            padding: 12px;
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid #3b82f6;
            color: #bae6fd;
            font-size: 0.85rem;
            line-height: 1.5;
            border-radius: 0 4px 4px 0;
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(30, 41, 59, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
        }

        .back-btn:hover {
            background: #6366f1;
            transform: translateY(-1px);
        }
    </style>
</head>

<body>

    <a href="../index.html" class="back-btn">‚Üê Back</a>

    <div id="ui-container">
        <h2>Electromagnet</h2>

        <div class="control-group">
            <div class="switch-wrapper">
                <span style="font-weight: 500; color: white;">Power Switch</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="switch-toggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>

        <div class="control-group">
            <label>Current (I) <span id="current-val">0.0 A</span></label>
            <input type="range" id="current-slider" min="0" max="5" step="0.1" value="0">
        </div>

        <div class="instruction">
            <strong>Tip:</strong> Drag the compass to explore the magnetic field. Notice how the needle aligns with the
            field lines created by the solenoid.
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        // --- Configuration ---
        const CONFIG = {
            solenoidRadius: 1.5,
            solenoidLength: 6,
            turns: 20,
            wireThickness: 0.1,
            coreRadius: 1.4,
            coreLength: 7,
            compassRadius: 1.2
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a); // Slate 900
        scene.fog = new THREE.Fog(0x0f172a, 20, 60);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 15, 10);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Don't go below ground
        controls.minDistance = 5;
        controls.maxDistance = 40;

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 12, 8);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.0001;
        scene.add(dirLight);

        const glowLight = new THREE.PointLight(0x818cf8, 0, 10); // Solenoid glow
        glowLight.position.set(0, 2, 0);
        scene.add(glowLight);

        // --- Laboratory Desk ---
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshStandardMaterial({
            color: 0x1e293b,
            roughness: 0.6,
            metalness: 0.2
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        plane.name = "TableSurface"; // For raycasting
        scene.add(plane);

        const grid = new THREE.GridHelper(50, 50, 0x334155, 0x1e293b);
        grid.position.y = 0.01;
        scene.add(grid);

        // --- Objects Container ---
        const apparatusGroup = new THREE.Group();
        apparatusGroup.position.y = 2; // Lift off table
        scene.add(apparatusGroup);

        // 1. Soft Iron Core
        const coreGeo = new THREE.CylinderGeometry(CONFIG.coreRadius, CONFIG.coreRadius, CONFIG.coreLength, 32);
        coreGeo.rotateZ(Math.PI / 2);
        const coreMat = new THREE.MeshStandardMaterial({
            color: 0xa1a1aa, // Zinc/Iron-ish
            roughness: 0.3,
            metalness: 0.8
        });
        const core = new THREE.Mesh(coreGeo, coreMat);
        core.castShadow = true;
        core.receiveShadow = true;
        apparatusGroup.add(core);

        // 2. Solenoid Coil
        const coilPoints = [];
        for (let i = 0; i <= CONFIG.turns * 10; i++) {
            const angle = (i / 10) * Math.PI * 2;
            const x = (i / (CONFIG.turns * 10)) * CONFIG.solenoidLength - CONFIG.solenoidLength / 2;
            const y = Math.cos(angle) * CONFIG.solenoidRadius;
            const z = Math.sin(angle) * CONFIG.solenoidRadius;
            coilPoints.push(new THREE.Vector3(x, y, z));
        }
        const coilCurve = new THREE.CatmullRomCurve3(coilPoints);
        const coilGeo = new THREE.TubeGeometry(coilCurve, 200, CONFIG.wireThickness, 8, false);
        const coilMat = new THREE.MeshStandardMaterial({
            color: 0xb87333, // Copper
            roughness: 0.3,
            metalness: 0.6
        });
        const solenoid = new THREE.Mesh(coilGeo, coilMat);
        solenoid.castShadow = true;
        apparatusGroup.add(solenoid);

        // 3. Mounts/Stand
        function createStand(x) {
            const standGeo = new THREE.BoxGeometry(0.5, 2.5, 4);
            const standMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const stand = new THREE.Mesh(standGeo, standMat);
            stand.position.set(x, -1.5, 0); // Position relative to core center (y=2 world -> y=0 local)
            stand.castShadow = true;
            return stand;
        }
        apparatusGroup.add(createStand(-2.5));
        apparatusGroup.add(createStand(2.5));

        // --- Compass (Ultra Realistic) ---
        const compassGroup = new THREE.Group();
        // Start position
        compassGroup.position.set(0, 0.2, 5);
        scene.add(compassGroup);

        // Compass Case
        const caseGeo = new THREE.CylinderGeometry(CONFIG.compassRadius, CONFIG.compassRadius, 0.4, 32);
        const caseMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.5, roughness: 0.2 });
        const compassCase = new THREE.Mesh(caseGeo, caseMat);
        compassCase.receiveShadow = true;
        compassCase.castShadow = true;
        compassGroup.add(compassCase);

        const glassGeo = new THREE.CylinderGeometry(CONFIG.compassRadius * 0.9, CONFIG.compassRadius * 0.9, 0.05, 32);
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, transmission: 0.9, opacity: 1, transparent: true, roughness: 0, metalness: 0, clearcoat: 1
        });
        const glass = new THREE.Mesh(glassGeo, glassMat);
        glass.position.y = 0.22;
        compassGroup.add(glass);

        // Compass Dial (White face)
        const dialGeo = new THREE.CircleGeometry(CONFIG.compassRadius * 0.85, 32);
        const dialMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const dial = new THREE.Mesh(dialGeo, dialMat);
        dial.rotation.x = -Math.PI / 2;
        dial.position.y = 0.205;
        compassGroup.add(dial);

        // N/S/E/W Markings
        const fontLoader = new THREE.TextureLoader(); // Mocking text with simple canvas shapes for now or primitives
        // Let's use simple primitives for N, S, E, W
        function createMark(text, angle, color) {
            // Placeholder: Just small boxes
            const mark = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.01, 0.3), new THREE.MeshBasicMaterial({ color: color }));
            mark.position.y = 0.21;
            mark.position.x = Math.sin(angle) * (CONFIG.compassRadius * 0.65);
            mark.position.z = Math.cos(angle) * (CONFIG.compassRadius * 0.65);
            mark.rotation.y = angle;
            compassGroup.add(mark);
        }
        createMark("N", Math.PI, 0xff0000); // Back Z is North usually in maps, but simulated physics... let's say Z- is North
        createMark("S", 0, 0x000000);
        createMark("E", -Math.PI / 2, 0x000000);
        createMark("W", Math.PI / 2, 0x000000);

        // Compass Center Pin
        const pinGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 16);
        const pinMat = new THREE.MeshStandardMaterial({ color: 0xb87333 }); // Gold/Brass
        const pin = new THREE.Mesh(pinGeo, pinMat);
        pin.position.y = 0.2;
        compassGroup.add(pin);

        // The Needle (The "Sexy" part)
        const needleGroup = new THREE.Group();
        needleGroup.position.y = 0.35;
        compassGroup.add(needleGroup);

        // North Tip (Red magnitude)
        const tipGeo = new THREE.ConeGeometry(0.15, 0.9, 4);
        // rotate cone to point along Z
        tipGeo.rotateX(Math.PI / 2);
        const northMat = new THREE.MeshStandardMaterial({ color: 0xe11d48, metalness: 0.3, roughness: 0.2 });
        const northTip = new THREE.Mesh(tipGeo, northMat);
        northTip.position.z = -0.45; // Pointing to -Z
        northTip.rotation.y = Math.PI; // Flip to point z-
        // Actually cone points up Y. rotateX(90) -> points Z. 
        // We want the point at -Z?
        // Let's reset geometry rotation
        const nGeo = new THREE.ConeGeometry(0.15, 0.9, 4);
        nGeo.rotateX(-Math.PI / 2); // Points along -Z
        const nTip = new THREE.Mesh(nGeo, northMat);
        nTip.position.z = -0.45;
        needleGroup.add(nTip);

        // South Tip (Silver/White)
        const sGeo = new THREE.ConeGeometry(0.15, 0.9, 4);
        sGeo.rotateX(Math.PI / 2); // Points along +Z
        const sMat = new THREE.MeshStandardMaterial({ color: 0xe2e8f0, metalness: 0.3, roughness: 0.2 });
        const sTip = new THREE.Mesh(sGeo, sMat);
        sTip.position.z = 0.45;
        needleGroup.add(sTip);


        // --- Interaction Logic (Drag Compass) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -0.2); // Plane at y=0.2

        window.addEventListener('mousedown', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(compassCase);
            if (intersects.length > 0) {
                isDragging = true;
                controls.enabled = false;
                document.body.style.cursor = 'grabbing';
            }
        });

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging) {
                raycaster.setFromCamera(mouse, camera);
                const point = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, point);
                if (point) {
                    compassGroup.position.set(point.x, 0.2, point.z);
                }
            } else {
                // Hover effect check
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(compassCase);
                document.body.style.cursor = intersects.length > 0 ? 'grab' : 'auto';
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            controls.enabled = true;
            document.body.style.cursor = 'auto';
        });


        // --- Physics & Simulation State ---
        const state = {
            current: 0,
            targetCurrent: 0,
            switchOn: false
        };

        const ui = {
            switch: document.getElementById('switch-toggle'),
            slider: document.getElementById('current-slider'),
            currentDisplay: document.getElementById('current-val')
        };

        // UI Event Listeners
        ui.switch.addEventListener('change', (e) => {
            state.switchOn = e.target.checked;
            updateUI();
        });

        ui.slider.addEventListener('input', (e) => {
            updateUI();
        });

        function updateUI() {
            const sliderVal = parseFloat(ui.slider.value);

            if (state.switchOn) {
                state.targetCurrent = sliderVal;
            } else {
                state.targetCurrent = 0;
            }

            ui.currentDisplay.innerText = state.switchOn
                ? `${state.targetCurrent.toFixed(1)} A`
                : "0.0 A (Off)";
        }

        function calculateMagneticField(position) {
            // Earth's Field (Weak, pointing North -> -Z)
            const B_earth = new THREE.Vector3(0, 0, -1).normalize().multiplyScalar(0.5);

            // Solenoid Field (Dipole Approximation)
            // Center of solenoid is (0, 2, 0)
            const center = new THREE.Vector3(0, 2, 0);
            const rVec = new THREE.Vector3().subVectors(position, center);
            const r = rVec.length();

            // Magnetic Moment M = N * I * A * vector
            // N = 20, I = state.current, A = PI * r^2
            // Direction: X axis (Solenoid lies along X axis)
            // Wait, geometry: Cylinder rotateZ(90) -> Lies on X axis. Correct.
            // So dipole moment is along X.
            // Right hand rule: 
            // If current flows one way, it points +X or -X. Let's say +X.

            const area = Math.PI * CONFIG.solenoidRadius * CONFIG.solenoidRadius;
            const momentMag = CONFIG.turns * state.current * area * 0.5; // Scaling factor for comfortable visual effect
            const moment = new THREE.Vector3(1, 0, 0).multiplyScalar(momentMag);

            // Dipole formula: B = (mu0/4pi) * (3(m.r)r - m*r^2) / r^5 
            // Simplified: B ~ (3(m.rHat)rHat - m) / r^3

            if (r < 0.1) return B_earth; // Avoid singularity

            const rHat = rVec.clone().normalize();
            const dot = moment.dot(rHat);

            const B_solenoid = new THREE.Vector3()
                .copy(rHat).multiplyScalar(3 * dot)
                .sub(moment)
                .divideScalar(Math.pow(r, 3));

            // Inside the core, field is uniform? The dipole approx is bad inside.
            // But compass is outside.
            // If compass is exactly inside (passed through geometry), it might go crazy.
            // Let's clamp distance to surface of solenoid roughly
            if (r < CONFIG.solenoidRadius) {
                // Hack: Inside field points along axis (+X)
                B_solenoid.set(1, 0, 0).multiplyScalar(momentMag * 0.2);
            }

            return new THREE.Vector3().addVectors(B_earth, B_solenoid);
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            // Ramp current for smooth effect
            state.current += (state.targetCurrent - state.current) * 0.1;

            // 1. Update Core visuals (heat/glow? No, just solenoid color potentially)
            // Solenoid glow intensity
            if (state.current > 0.1) {
                glowLight.intensity = state.current * 0.5;
                solenoid.material.emissive.setHex(0xff4400);
                solenoid.material.emissiveIntensity = state.current * 0.2;
            } else {
                glowLight.intensity = 0;
                solenoid.material.emissive.setHex(0x000000);
            }

            // 2. Compass Physics
            // Compass position in world
            const compassPos = compassGroup.position.clone();
            compassPos.y += 0.35; // Height of needle

            const B = calculateMagneticField(compassPos);

            // Calculate target angle
            // Needle rotates in X-Z plane (y-axis is pivot)
            // We need the angle of B vector projected on XZ plane
            const angle = Math.atan2(B.x, B.z);
            // atan2(x, z) gives angle from Z axis? 
            // If B is (0,0,-1) [North], atan2(0, -1) = PI.
            // If B is (1,0,0) [East], atan2(1, 0) = PI/2.

            // Needle points along -Z by default (North Tip).
            // Visual rotation: default 0 means North Tip points -Z.
            // So if field is North (-Z), rotation should be 0. (PI matches? let's check).
            // If rotation.y = 0: N-Tip at -Z.
            // If B is North (0,0,-1), we want N-Tip to point North.
            // So rotation 0 is correct.
            // atan2(0,-1) is PI. So rotation = angle - PI?

            let targetRotation = angle - Math.PI;

            // Smooth rotation (sexy dampening)
            // Handle shortest path for rotation (avoid 359 -> 1 flips)
            let currentRotation = needleGroup.rotation.y;

            // Normalize angles
            while (targetRotation - currentRotation > Math.PI) targetRotation -= Math.PI * 2;
            while (targetRotation - currentRotation < -Math.PI) targetRotation += Math.PI * 2;

            const speed = 0.1 + (state.current * 0.02); // React faster with stronger field
            needleGroup.rotation.y += (targetRotation - currentRotation) * speed;

            // Needle Dip (optional realism: magnetic dip)
            // If B has Y component, needle dips.
            // const dipAngle = Math.atan2(B.y, Math.sqrt(B.x*B.x + B.z*B.z));
            // needleGroup.rotation.x = -dipAngle * 0.5; // Limited dip


            controls.update();
            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>