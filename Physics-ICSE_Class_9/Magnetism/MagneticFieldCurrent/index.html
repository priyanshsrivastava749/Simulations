<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electromagnet & Compass Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            color: white;
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 23, 42, 0.8);
            padding: 24px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            width: 300px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }

        h2 {
            margin: 0 0 20px 0;
            font-size: 1.5rem;
            font-weight: 600;
            background: linear-gradient(90deg, #818cf8, #c084fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .control-group {
            margin-bottom: 24px;
        }

        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #cbd5e1;
            font-size: 0.95rem;
            font-weight: 500;
        }

        /* Custom Range Slider */
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #818cf8;
            border: 2px solid #1e293b;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 0 10px rgba(129, 140, 248, 0.5);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #a5b4fc;
        }

        /* Toggle Switch */
        .switch-wrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #1e293b;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 52px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #475569;
            transition: .3s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input:checked+.slider {
            background-color: #10b981;
        }

        input:checked+.slider:before {
            transform: translateX(24px);
        }

        .instruction {
            margin-top: 20px;
            padding: 12px;
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid #3b82f6;
            color: #bae6fd;
            font-size: 0.85rem;
            line-height: 1.5;
            border-radius: 0 4px 4px 0;
        }

        .btn {
            width: 100%;
            padding: 10px;
            background: #334155;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #475569;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(30, 41, 59, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        .back-btn:hover {
            background: #6366f1;
            transform: translateY(-1px);
        }

        /* Overlay for Circuit Diagram */
        #diagram-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #diagram-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .diagram-content {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            position: relative;
        }

        .close-diagram {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #333;
        }
    </style>
</head>

<body>

    <a href="../index.html" class="back-btn">‚Üê Back</a>

    <div id="ui-container">
        <h2>Electromagnet</h2>

        <div class="control-group">
            <div class="switch-wrapper">
                <span style="font-weight: 500; color: white;">Power Switch</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="switch-toggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>

        <div class="control-group">
            <label>Current (I) <span id="current-val">0.0 A</span></label>
            <input type="range" id="current-slider" min="0" max="5" step="0.1" value="0">
        </div>

        <div class="control-group">
            <div class="switch-wrapper" style="background: transparent; border: none; padding: 0;">
                <label style="margin: 0; width: 100%; cursor: pointer;">
                    <span>Show Field Lines</span>
                    <label class="toggle-switch" style="transform: scale(0.8);">
                        <input type="checkbox" id="field-toggle">
                        <span class="slider"></span>
                    </label>
                </label>
            </div>
        </div>

        <button class="btn" id="diagram-btn">View Circuit Diagram</button>

        <div class="instruction">
            <strong>Tip:</strong> Drag the compass to discover field direction. Toggle Field Lines to see the magnetic
            loops.
        </div>
    </div>

    <!-- Circuit Diagram Overlay -->
    <div id="diagram-overlay">
        <div class="diagram-content">
            <button class="close-diagram" id="close-diagram">&times;</button>
            <h3 style="color: #333; margin-top: 0;">Circuit Diagram</h3>
            <!-- SVG Circuit Diagram -->
            <svg width="400" height="300" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
                <style>
                    .circuit-line {
                        stroke: #000;
                        stroke-width: 2;
                        fill: none;
                    }

                    .component-label {
                        font-family: sans-serif;
                        font-size: 14px;
                        fill: #333;
                    }
                </style>
                <!-- Battery -->
                <line x1="50" y1="150" x2="150" y2="150" class="circuit-line" />
                <line x1="90" y1="135" x2="90" y2="165" class="circuit-line" stroke-width="4" /> <!-- Long bar -->
                <line x1="100" y1="142" x2="100" y2="158" class="circuit-line" stroke-width="4" /> <!-- Short bar -->
                <text x="85" y="125" class="component-label">+</text>

                <!-- Switch -->
                <line x1="150" y1="150" x2="180" y2="150" class="circuit-line" />
                <line x1="180" y1="150" x2="210" y2="140" class="circuit-line" id="svg-switch-arm" />
                <!-- Open switch -->
                <line x1="210" y1="150" x2="250" y2="150" class="circuit-line" />
                <circle cx="180" cy="150" r="3" fill="#000" />
                <circle cx="210" cy="150" r="3" fill="#000" />
                <text x="185" y="180" class="component-label">Switch (K)</text>

                <!-- Solenoid (Inductor symbol) -->
                <path d="M 250 150 Q 260 120 270 150 T 290 150 T 310 150 T 330 150" class="circuit-line" />
                <rect x="255" y="145" width="70" height="10" fill="none" stroke="none" /> <!-- invisible box -->
                <text x="270" y="120" class="component-label">Solenoid</text>

                <!-- Soft Iron Core Indication -->
                <line x1="255" y1="155" x2="325" y2="155" class="circuit-line" style="stroke-dasharray: 4,2;" />
                <text x="270" y="180" class="component-label">Iron Core</text>

                <!-- Rheostat -->
                <line x1="330" y1="150" x2="330" y2="250" class="circuit-line" />
                <line x1="330" y1="250" x2="50" y2="250" class="circuit-line" />
                <line x1="50" y1="250" x2="50" y2="150" class="circuit-line" />

                <!-- Arrow for Variable R (Rheostat logic abstract) -->
                <text x="180" y="270" class="component-label">Connecting Wires</text>
            </svg>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        // --- Configuration ---
        const CONFIG = {
            solenoidRadius: 1.5,
            solenoidLength: 6,
            turns: 20,
            wireThickness: 0.1,
            coreRadius: 1.4,
            coreLength: 7,
            compassRadius: 1.2
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a); // Slate 900
        scene.fog = new THREE.Fog(0x0f172a, 20, 60);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 15, 12);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.minDistance = 5;
        controls.maxDistance = 40;

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 12, 8);
        dirLight.castShadow = true;
        dirLight.shadow.bias = -0.0001;
        scene.add(dirLight);

        const glowLight = new THREE.PointLight(0x818cf8, 0, 15); // Extended range
        glowLight.position.set(0, 2, 0);
        scene.add(glowLight);

        // --- Objects ---
        const apparatusGroup = new THREE.Group();
        apparatusGroup.position.y = 2;
        scene.add(apparatusGroup);

        // Table
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.6, metalness: 0.2 })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        scene.add(new THREE.GridHelper(50, 50, 0x334155, 0x1e293b));

        // Core
        const core = new THREE.Mesh(
            new THREE.CylinderGeometry(CONFIG.coreRadius, CONFIG.coreRadius, CONFIG.coreLength, 32).rotateZ(Math.PI / 2),
            new THREE.MeshStandardMaterial({ color: 0xa1a1aa, roughness: 0.3, metalness: 0.8 })
        );
        core.castShadow = true;
        apparatusGroup.add(core);

        // Solenoid
        const coilPoints = [];
        const startX = -CONFIG.solenoidLength / 2;
        const endX = CONFIG.solenoidLength / 2;
        for (let i = 0; i <= CONFIG.turns * 10; i++) {
            const angle = (i / 10) * Math.PI * 2;
            const x = (i / (CONFIG.turns * 10)) * CONFIG.solenoidLength + startX;
            const y = Math.cos(angle) * CONFIG.solenoidRadius;
            const z = Math.sin(angle) * CONFIG.solenoidRadius;
            coilPoints.push(new THREE.Vector3(x, y, z));
        }
        const coilCurve = new THREE.CatmullRomCurve3(coilPoints);
        const solenoid = new THREE.Mesh(
            new THREE.TubeGeometry(coilCurve, 200, CONFIG.wireThickness, 8, false),
            new THREE.MeshStandardMaterial({ color: 0xb87333, roughness: 0.3 })
        );
        solenoid.castShadow = true;
        apparatusGroup.add(solenoid);

        // Connecting Wires (Visual fake)
        function createWire(p1, p2) {
            const lineCurve = new THREE.LineCurve3(p1, p2);
            return new THREE.Mesh(
                new THREE.TubeGeometry(lineCurve, 4, 0.08, 8, false),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
        }
        // Wire from Left End to "Battery" area under table or side
        const leftEnd = new THREE.Vector3(startX, -CONFIG.solenoidRadius, 0);
        const rightEnd = new THREE.Vector3(endX, -CONFIG.solenoidRadius, 0);

        // Just drop them down to the "stands"
        const wireL = createWire(leftEnd, new THREE.Vector3(startX, -1.5, 0));
        const wireR = createWire(rightEnd, new THREE.Vector3(endX, -1.5, 0));
        apparatusGroup.add(wireL);
        apparatusGroup.add(wireR);


        // Stands
        const standMat = new THREE.MeshStandardMaterial({ color: 0x1f2937 });
        const s1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2.5, 4), standMat);
        s1.position.set(-2.5, -1.5, 0);
        s1.castShadow = true;
        apparatusGroup.add(s1);

        const s2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2.5, 4), standMat);
        s2.position.set(2.5, -1.5, 0);
        s2.castShadow = true;
        apparatusGroup.add(s2);

        // --- Compass ---
        const compassGroup = new THREE.Group();
        compassGroup.position.set(0, 0.2, 5);
        scene.add(compassGroup);

        const compassCase = new THREE.Mesh(
            new THREE.CylinderGeometry(CONFIG.compassRadius, CONFIG.compassRadius, 0.4, 32),
            new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.5, roughness: 0.2 })
        );
        compassCase.castShadow = true;
        compassGroup.add(compassCase);

        // Glass
        compassGroup.add(new THREE.Mesh(
            new THREE.CylinderGeometry(CONFIG.compassRadius * 0.9, CONFIG.compassRadius * 0.9, 0.05, 32),
            new THREE.MeshPhysicalMaterial({ color: 0xffffff, transmission: 0.9, opacity: 1, transparent: true, roughness: 0 })
        ).translateY(0.22));

        // Dial
        const dial = new THREE.Mesh(
            new THREE.CircleGeometry(CONFIG.compassRadius * 0.85, 32),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        dial.rotation.x = -Math.PI / 2;
        dial.position.y = 0.205;
        compassGroup.add(dial);

        // Markings
        const markings = new THREE.Group();
        ['N', 'E', 'S', 'W'].forEach((dir, i) => {
            const angle = i * Math.PI / 2 + Math.PI; // Correct alignment
            const mark = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.01, 0.4), new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? 0xef4444 : 0x000000 }));
            mark.position.set(Math.sin(angle) * 0.8, 0.21, Math.cos(angle) * 0.8);
            mark.rotation.y = angle;
            markings.add(mark);
        });
        compassGroup.add(markings);

        // Needle
        const needleGroup = new THREE.Group();
        needleGroup.position.y = 0.35;
        compassGroup.add(needleGroup);

        const nTip = new THREE.Mesh(
            new THREE.ConeGeometry(0.15, 0.9, 4).rotateX(-Math.PI / 2),
            new THREE.MeshStandardMaterial({ color: 0xe11d48 })
        );
        nTip.position.z = -0.45;
        needleGroup.add(nTip);

        const sTip = new THREE.Mesh(
            new THREE.ConeGeometry(0.15, 0.9, 4).rotateX(Math.PI / 2),
            new THREE.MeshStandardMaterial({ color: 0xe2e8f0 })
        );
        sTip.position.z = 0.45;
        needleGroup.add(sTip);


        // --- Field Lines Visualization ---
        const fieldLinesGroup = new THREE.Group();
        fieldLinesGroup.visible = false; // Hidden by default
        scene.add(fieldLinesGroup);

        // Precompute lines? Or dynamic?
        // Dynamic allows seeing them fade. But computationally expensive to stream.
        // Let's generate static geometry shapes that we just scale/fade.

        function generateStreamlines() {
            const count = 30; // Number of lines
            const steps = 100;
            const mat = new THREE.LineBasicMaterial({ color: 0x10b981, transparent: true, opacity: 0.6 });

            // Seed points within the coil cross section distributed around
            // Or better: seed points on a circle at the center of the coil and trace out?
            // Actually, seed points on the face of the core (x = -3).

            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                // Distribute radius: some close, some far
                const r = 0.5 + Math.random() * 2.0;
                const start = new THREE.Vector3(-0.1, Math.cos(angle) * r + 2, Math.sin(angle) * r);

                // Trace field
                // BUT: We need a field function that works for tracing. 
                // The dipole approximation I used for compass is too simple for drawing meaningful loops near the coil.
                // Reverting to a simple Dipole vector field for visual lines might look okay from distance.

                const points = [];
                let curr = start.clone();
                // We'll trace both forward and backward from center
                // Actually let's trace from x=-5 to 5

                // Better approach for visuals: Ellipses that look like field lines.
                // Much cheaper and "cleaner" looking than integrating a noisy field.

                // Real field lines of a solenoid are loops.
                // Let's make distorted ellipses.
                const path = new THREE.Path();
                const ellipseCurve = new THREE.EllipseCurve(
                    0, 2, // ax, ay (Center X, Center Y -- relative to group rotation)
                    // Wait, we need 3D loops.
                    // Lets just use Torus knots or multiple EllipseCurves rotated.
                );
            }

            // Re-implementing simplified "Field Loops" using Tubing/Lines
            // Loops passing through the coil.
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                // Each line is a loop in a plane rotated by 'angle' around X axis (solenoid axis).
                // Wait, solenoid axis is X. Center at (0,2,0).
                // So planes pass through the X axis.

                const loopPoints = [];
                // Create a squashed circle/ellipse
                const a = 8; // Length along X
                const b = 2 + (i % 3); // Height away from axis

                for (let t = 0; t <= 64; t++) {
                    const theta = (t / 64) * Math.PI * 2;
                    const lx = Math.cos(theta) * a;
                    const ly = Math.sin(theta) * b;

                    // This is in 2D. Now map to 3D.
                    // X coordinate is lx.
                    // Radial coordinate is ly.
                    // Angle around X axis is 'angle'.

                    const x = lx;
                    // Start from center (0, 2, 0).
                    const radius = Math.abs(ly); // distance from wire axis
                    // Need to offset so it doesn't cross exactly center?
                    // Actually solenoid field goes THROUGH center.

                    // Let's use standard parametric for Ellipsoid-ish
                    // X = a cos(t)
                    // Y = b sin(t) * cos(angle)
                    // Z = b sin(t) * sin(angle)

                    // Offset Y by 2.
                    loopPoints.push(new THREE.Vector3(x, 2 + Math.cos(angle) * Math.sin(theta) * b, Math.sin(angle) * Math.sin(theta) * b));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(loopPoints);
                const line = new THREE.Line(geometry, mat);
                fieldLinesGroup.add(line);
            }
        }
        generateStreamlines();


        // --- Interaction ---
        const ui = {
            switch: document.getElementById('switch-toggle'),
            slider: document.getElementById('current-slider'),
            currVal: document.getElementById('current-val'),
            field: document.getElementById('field-toggle'),
            diagBtn: document.getElementById('diagram-btn'),
            diagOverlay: document.getElementById('diagram-overlay'),
            diagClose: document.getElementById('close-diagram')
        };

        const state = { current: 0, target: 0, on: false };

        ui.switch.addEventListener('change', (e) => {
            state.on = e.target.checked;
            updateUI();
            // Animate SVG diagram switch?
            const arm = document.getElementById('svg-switch-arm');
            if (state.on) {
                arm.setAttribute('y2', '150'); // Closed
            } else {
                arm.setAttribute('y2', '140'); // Open
            }
        });

        ui.slider.addEventListener('input', updateUI);

        ui.field.addEventListener('change', (e) => {
            fieldLinesGroup.visible = e.target.checked;
        });

        ui.diagBtn.addEventListener('click', () => ui.diagOverlay.classList.add('visible'));
        ui.diagClose.addEventListener('click', () => ui.diagOverlay.classList.remove('visible'));

        function updateUI() {
            const val = parseFloat(ui.slider.value);
            state.target = state.on ? val : 0;
            ui.currVal.innerText = state.on ? val.toFixed(1) + " A" : "0.0 A (Off)";
        }

        // Draggable Compass
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -0.2);

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', () => { isDragging = false; controls.enabled = true; });

        function onMouseDown(e) {
            updateMouse(e);
            raycaster.setFromCamera(mouse, camera);
            if (raycaster.intersectObject(compassCase).length > 0) {
                isDragging = true;
                controls.enabled = false;
            }
        }

        function onMouseMove(e) {
            updateMouse(e);
            if (isDragging) {
                raycaster.setFromCamera(mouse, camera);
                const p = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, p);
                if (p) compassGroup.position.set(p.x, 0.2, p.z);
            }
        }

        function updateMouse(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        }

        // --- Physics Implementation ---
        function calculateField(pos) {
            const B_earth = new THREE.Vector3(0, 0, -1).multiplyScalar(0.5);

            // Dipole Model
            const center = new THREE.Vector3(0, 2, 0);
            const rVec = new THREE.Vector3().subVectors(pos, center);
            const r = rVec.length();

            // Avoid singularity inside
            if (r < 1.0) return new THREE.Vector3(1, 0, 0).multiplyScalar(state.current * 2);

            const momentMag = 200 * state.current; // Tuned for effect
            const moment = new THREE.Vector3(1, 0, 0).multiplyScalar(momentMag);

            const rHat = rVec.clone().normalize();
            const dot = moment.dot(rHat);

            const B_dip = new THREE.Vector3()
                .copy(rHat).multiplyScalar(3 * dot)
                .sub(moment)
                .divideScalar(Math.pow(r, 3));

            return B_earth.add(B_dip);
        }

        // --- Animate ---
        function animate() {
            requestAnimationFrame(animate);

            // Smooth current
            state.current += (state.target - state.current) * 0.1;

            // Glow effect
            if (state.current > 0.1) {
                glowLight.intensity = state.current * 0.8;
                solenoid.material.emissive.setHex(0xff4400);
                solenoid.material.emissiveIntensity = state.current * 0.1;
            } else {
                glowLight.intensity = 0;
                solenoid.material.emissive.setHex(0x000000);
            }

            // Compass Physics
            const needleWorldPos = new THREE.Vector3().setFromMatrixPosition(needleGroup.matrixWorld);
            const B = calculateField(needleWorldPos);

            // Angle in XZ plane
            let targetAng = Math.atan2(B.x, B.z) - Math.PI;
            let currAng = needleGroup.rotation.y;

            // Standardize
            while (targetAng - currAng > Math.PI) targetAng -= Math.PI * 2;
            while (targetAng - currAng < -Math.PI) targetAng += Math.PI * 2;

            needleGroup.rotation.y += (targetAng - currAng) * 0.15;

            // Field Lines Opacity
            fieldLinesGroup.children.forEach(line => {
                line.material.opacity = (state.current / 5) * 0.6;
            });

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>